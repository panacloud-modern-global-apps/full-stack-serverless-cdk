<?xml version="1.0" encoding="UTF-8"?>
<testsuites name="jest tests" tests="44" failures="0" errors="0" time="4.529">
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2020-11-28T06:20:50" time="3.539" tests="43">
    <testcase classname=" the &quot;Root&quot; construct is a special construct which can be used as the root of the tree" name=" the &quot;Root&quot; construct is a special construct which can be used as the root of the tree" time="0.004">
    </testcase>
    <testcase classname=" constructs cannot be created with an empty name unless they are root" name=" constructs cannot be created with an empty name unless they are root" time="0.041">
    </testcase>
    <testcase classname=" construct.name returns the name of the construct" name=" construct.name returns the name of the construct" time="0.001">
    </testcase>
    <testcase classname=" construct id can use any character except the path separator" name=" construct id can use any character except the path separator" time="0.003">
    </testcase>
    <testcase classname=" if construct id contains path seperators, they will be replaced by double-dash" name=" if construct id contains path seperators, they will be replaced by double-dash" time="0.006">
    </testcase>
    <testcase classname=" if &quot;undefined&quot; is forcefully used as an &quot;id&quot;, it will be treated as an empty string" name=" if &quot;undefined&quot; is forcefully used as an &quot;id&quot;, it will be treated as an empty string" time="0">
    </testcase>
    <testcase classname=" construct.uniqueId (deprecated) returns a tree-unique alphanumeric id of this construct" name=" construct.uniqueId (deprecated) returns a tree-unique alphanumeric id of this construct" time="0.002">
    </testcase>
    <testcase classname=" cannot calculate uniqueId if the construct path is [&quot;Default&quot;]" name=" cannot calculate uniqueId if the construct path is [&quot;Default&quot;]" time="0.016">
    </testcase>
    <testcase classname=" node.addr returns an opaque app-unique address for any construct" name=" node.addr returns an opaque app-unique address for any construct" time="0.001">
    </testcase>
    <testcase classname=" node.addr excludes &quot;default&quot; from the address calculation" name=" node.addr excludes &quot;default&quot; from the address calculation" time="0.002">
    </testcase>
    <testcase classname=" construct.getChildren() returns an array of all children" name=" construct.getChildren() returns an array of all children" time="0">
    </testcase>
    <testcase classname=" construct.findChild(name) can be used to retrieve a child from a parent" name=" construct.findChild(name) can be used to retrieve a child from a parent" time="0">
    </testcase>
    <testcase classname=" construct.getChild(name) can be used to retrieve a child from a parent" name=" construct.getChild(name) can be used to retrieve a child from a parent" time="0.001">
    </testcase>
    <testcase classname=" construct.getContext(key) can be used to read a value from context defined at the root level" name=" construct.getContext(key) can be used to read a value from context defined at the root level" time="0.001">
    </testcase>
    <testcase classname=" construct.setContext(k,v) sets context at some level and construct.getContext(key) will return the lowermost value defined in the stack" name=" construct.setContext(k,v) sets context at some level and construct.getContext(key) will return the lowermost value defined in the stack" time="0.001">
    </testcase>
    <testcase classname=" construct.setContext(key, value) can only be called before adding any children" name=" construct.setContext(key, value) can only be called before adding any children" time="0">
    </testcase>
    <testcase classname=" construct.pathParts returns an array of strings of all names from root to node" name=" construct.pathParts returns an array of strings of all names from root to node" time="0.001">
    </testcase>
    <testcase classname=" if a root construct has a name, it should be included in the path" name=" if a root construct has a name, it should be included in the path" time="0">
    </testcase>
    <testcase classname=" construct can not be created with the name of a sibling" name=" construct can not be created with the name of a sibling" time="0.001">
    </testcase>
    <testcase classname=" addMetadata(type, data) can be used to attach metadata to constructs" name=" addMetadata(type, data) can be used to attach metadata to constructs" time="0.003">
    </testcase>
    <testcase classname=" addMetadata(type, undefined/null) is ignored" name=" addMetadata(type, undefined/null) is ignored" time="0.001">
    </testcase>
    <testcase classname=" addWarning(message) can be used to add a &quot;WARNING&quot; message entry to the construct" name=" addWarning(message) can be used to add a &quot;WARNING&quot; message entry to the construct" time="0.001">
    </testcase>
    <testcase classname=" addError(message) can be used to add a &quot;ERROR&quot; message entry to the construct" name=" addError(message) can be used to add a &quot;ERROR&quot; message entry to the construct" time="0">
    </testcase>
    <testcase classname=" addInfo(message) can be used to add an &quot;INFO&quot; message entry to the construct" name=" addInfo(message) can be used to add an &quot;INFO&quot; message entry to the construct" time="0.001">
    </testcase>
    <testcase classname=" multiple children of the same type, with explicit names are welcome" name=" multiple children of the same type, with explicit names are welcome" time="0">
    </testcase>
    <testcase classname=" construct.onValidate() can be implemented to perform validation, node.validate() will return all errors from the subtree (DFS)" name=" construct.onValidate() can be implemented to perform validation, node.validate() will return all errors from the subtree (DFS)" time="0.001">
    </testcase>
    <testcase classname=" node.addValidation() can be implemented to perform validation, node.validate() will return errors" name=" node.addValidation() can be implemented to perform validation, node.validate() will return errors" time="0.001">
    </testcase>
    <testcase classname=" node.validate() returns an empty array if the construct does not implement IValidation" name=" node.validate() returns an empty array if the construct does not implement IValidation" time="0.001">
    </testcase>
    <testcase classname=" node.addValidation() can be used to add a validation function to a construct" name=" node.addValidation() can be used to add a validation function to a construct" time="0">
    </testcase>
    <testcase classname=" both &quot;onValidate()&quot; and &quot;addValidation()&quot; works" name=" both &quot;onValidate()&quot; and &quot;addValidation()&quot; works" time="0">
    </testcase>
    <testcase classname=" construct.lock() protects against adding children anywhere under this construct (direct or indirect)" name=" construct.lock() protects against adding children anywhere under this construct (direct or indirect)" time="0.002">
    </testcase>
    <testcase classname=" findAll returns a list of all children in either DFS or BFS" name=" findAll returns a list of all children in either DFS or BFS" time="0.001">
    </testcase>
    <testcase classname=" ancestors returns a list of parents up to root" name=" ancestors returns a list of parents up to root" time="0.001">
    </testcase>
    <testcase classname=" &quot;root&quot; returns the root construct" name=" &quot;root&quot; returns the root construct" time="0">
    </testcase>
    <testcase classname="defaultChild returns the child with id &quot;Resource&quot;" name="defaultChild returns the child with id &quot;Resource&quot;" time="0.001">
    </testcase>
    <testcase classname="defaultChild returns the child with id &quot;Default&quot;" name="defaultChild returns the child with id &quot;Default&quot;" time="0">
    </testcase>
    <testcase classname="defaultChild can override defaultChild" name="defaultChild can override defaultChild" time="0">
    </testcase>
    <testcase classname="defaultChild returns &quot;undefined&quot; if there is no default" name="defaultChild returns &quot;undefined&quot; if there is no default" time="0">
    </testcase>
    <testcase classname="defaultChild fails if there are both &quot;Resource&quot; and &quot;Default&quot;" name="defaultChild fails if there are both &quot;Resource&quot; and &quot;Default&quot;" time="0.001">
    </testcase>
    <testcase classname="defaultChild constructs created in an Aspect are prepared" name="defaultChild constructs created in an Aspect are prepared" time="0.001">
    </testcase>
    <testcase classname="construct prepare created constructs are prepared" name="construct prepare created constructs are prepared" time="0.001">
    </testcase>
    <testcase classname="construct prepare only constructs with onPrepare function are prepared" name="construct prepare only constructs with onPrepare function are prepared" time="0">
    </testcase>
    <testcase classname="construct prepare only constructs with onPrepare function are prepared" name="construct prepare only constructs with onPrepare function are prepared" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="undefined" errors="0" failures="0" skipped="0" timestamp="2020-11-28T06:20:54" time="0.168" tests="1">
    <testcase classname=" Aspects are invoked only once" name=" Aspects are invoked only once" time="0.002">
    </testcase>
  </testsuite>
</testsuites>